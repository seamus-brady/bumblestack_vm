// Generated automatically from /home/seamus/GitHub/bumblestack-repos/bumblestack/src/scripts/json.wren. Do not edit.
static const char* jsonModuleSource =
"class BumbleVM {\n"
"  static jsonPrint(string) {\n"
"    System.print(JSON.parse(string))\n"
"  }\n"
"\n"
"}\n"
"\n"
"class JSON {\n"
"  static parse(string) {\n"
"    return JSONParser.new(string).parse\n"
"  }\n"
"\n"
"  static stringify(object) {\n"
"    return JSONStringifier.new(object).toString\n"
"  }\n"
"\n"
"  static tokenize(string) {\n"
"    return JSONScanner.new(string).tokenize\n"
"  }\n"
"}\n"
"\n"
"class JSONStringifier {\n"
"  construct new(object) {\n"
"    _object = object\n"
"  }\n"
"\n"
"  toString { stringify(_object) }\n"
"\n"
"  stringify(obj) {\n"
"    if (obj is Num || obj is Bool || obj is Null) {\n"
"      return obj.toString\n"
"    } else if (obj is String) {\n"
"      var substrings = []\n"
"      // Escape special characters\n"
"      for (char in obj) {\n"
"        if (char == \"\\\"\") {\n"
"          substrings.add(\"\\\\\\\"\")\n"
"        } else if (char == \"\\\\\") {\n"
"          substrings.add(\"\\\\\\\\\")\n"
"        } else if (char == \"\\b\") {\n"
"          substrings.add(\"\\\\b\")\n"
"        } else if (char == \"\\f\") {\n"
"          substrings.add(\"\\\\f\")\n"
"        } else if (char == \"\\n\") {\n"
"          substrings.add(\"\\\\n\")\n"
"        } else if (char == \"\\r\") {\n"
"          substrings.add(\"\\\\r\")\n"
"        } else if (char == \"\\t\") {\n"
"          substrings.add(\"\\\\t\")\n"
"        } else {\n"
"          substrings.add(char)\n"
"        }\n"
"      }\n"
"      return \"\\\"\" + substrings.join(\"\") + \"\\\"\"\n"
"\n"
"    } else if (obj is List) {\n"
"      var substrings = obj.map { |o| stringify(o) }\n"
"      return \"[\" + substrings.join(\",\") + \"]\"\n"
"\n"
"    } else if (obj is Map) {\n"
"      var substrings = obj.keys.map { |key|\n"
"        return stringify(key) + \":\" + stringify(obj[key])\n"
"      }\n"
"      return \"{\" + substrings.join(\",\") + \"}\"\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"class JSONParser {\n"
"  construct new(input) {\n"
"    _input = input\n"
"    _tokens = []\n"
"  }\n"
"\n"
"  valueTypes { [Token.String, Token.Number, Token.Bool, Token.Null] }\n"
"\n"
"  parse { nest(JSONScanner.new(_input).tokenize) }\n"
"\n"
"  nest(tokens) {\n"
"    if (tokens.count == 0) { parsingError }\n"
"\n"
"    var token = tokens.removeAt(0)\n"
"\n"
"    if (token.type == Token.LeftBrace) {\n"
"      // Making a Map\n"
"      var map = {}\n"
"\n"
"      while (tokens[0].type != Token.RightBrace) {\n"
"        var key = tokens.removeAt(0)\n"
"        if (key.type != Token.String) { parsingError(key) }\n"
"\n"
"        var next = tokens.removeAt(0)\n"
"        if (next.type != Token.Colon) { parsingError(next) }\n"
"\n"
"        var value = nest(tokens)\n"
"        map[key.value] = value\n"
"\n"
"        if (tokens.count >= 2 &&\n"
"            tokens[0].type == Token.Comma &&\n"
"            tokens[1].type != Token.RightBrace) {\n"
"          tokens.removeAt(0)\n"
"        }\n"
"      }\n"
"\n"
"      // Remove Token.RightBrace\n"
"      tokens.removeAt(0)\n"
"\n"
"      return map\n"
"\n"
"    } else if (token.type == Token.LeftBracket) {\n"
"      // Making a List\n"
"      var list = []\n"
"      while (tokens[0].type != Token.RightBracket) {\n"
"        list.add(nest(tokens))\n"
"\n"
"        if (tokens[0].type == Token.Comma) {\n"
"          tokens.removeAt(0)\n"
"        }\n"
"      }\n"
"\n"
"      // Remove Token.RightBracket\n"
"      tokens.removeAt(0)\n"
"\n"
"      return list\n"
"\n"
"    } else if (valueTypes.contains(token.type)) {\n"
"      return token.value\n"
"\n"
"    } else { parsingError(token) }\n"
"  }\n"
"\n"
"  parsingError (token) {\n"
"    var position = Helper.getPositionForIndex(_input, token.index)\n"
"    invalidJSON(\"Unexpected \\\"%(token)\\\" at line %(position[\"line\"]), column %(position[\"column\"])\")\n"
"  }\n"
"\n"
"  parsingError {\n"
"    invalidJSON(\"\")\n"
"  }\n"
"\n"
"  invalidJSON(message) {\n"
"    var base = \"Invalid JSON\"\n"
"    Fiber.abort(message.count > 0 ? \"%(base): %(message)\" : base)\n"
"  }\n"
"}\n"
"\n"
"class JSONScanner {\n"
"  construct new(input) {\n"
"    _input = input\n"
"    _tokens = []\n"
"    // first unconsumed char\n"
"    _start = 0\n"
"    // char that will be considered next\n"
"    _cursor = 0\n"
"  }\n"
"\n"
"  numberChars { \"0123456789.-\" }\n"
"  whitespaceChars { \" \\r\\t\\n\"}\n"
"  escapedCharMap {\n"
"    return {\n"
"      \"\\\"\": \"\\\"\",\n"
"      \"\\\\\": \"\\\\\",\n"
"      \"b\": \"\\b\",\n"
"      \"f\": \"\\f\",\n"
"      \"n\": \"\\n\",\n"
"      \"r\": \"\\r\",\n"
"      \"t\": \"\\t\"\n"
"    }\n"
"  }\n"
"\n"
"  tokenize {\n"
"    while (!isAtEnd()) {\n"
"      _start = _cursor\n"
"      scanToken()\n"
"    }\n"
"\n"
"    addToken(Token.End)\n"
"\n"
"    return _tokens\n"
"  }\n"
"\n"
"  scanToken () {\n"
"    var char = advance()\n"
"\n"
"    if (char == \"{\") {\n"
"      addToken(Token.LeftBrace)\n"
"    } else if (char == \"}\") {\n"
"      addToken(Token.RightBrace)\n"
"    } else if (char == \"[\") {\n"
"      addToken(Token.LeftBracket)\n"
"    } else if (char == \"]\") {\n"
"      addToken(Token.RightBracket)\n"
"    } else if (char == \":\") {\n"
"      addToken(Token.Colon)\n"
"    } else if (char == \",\") {\n"
"      addToken(Token.Comma)\n"
"    } else if (char == \"/\") {\n"
"      // Don't allow comments\n"
"      scanningError\n"
"    } else if (char == \"\\\"\") {\n"
"      scanString()\n"
"    } else if (numberChars.contains(char)) {\n"
"      scanNumber()\n"
"    } else if (isAlpha(char)) {\n"
"      scanIdentifier()\n"
"    } else if (whitespaceChars.contains(char)) {\n"
"      // pass\n"
"    } else {\n"
"      scanningError\n"
"    }\n"
"  }\n"
"\n"
"  scanString () {\n"
"    var isEscaping = false\n"
"    var valueInProgress = []\n"
"\n"
"    while ((peek() != \"\\\"\" || isEscaping) && !isAtEnd()) {\n"
"      var char = advance()\n"
"\n"
"      if (isEscaping) {\n"
"        if (escapedCharMap.containsKey(char)) {\n"
"          valueInProgress.add(escapedCharMap[char])\n"
"        } else if (char == \"u\") { // unicode char!\n"
"          var charsToPull = 4\n"
"          var start = _cursor\n"
"          var hexString = Helper.slice(_input, start, start + charsToPull).join(\"\")\n"
"\n"
"          var decimal = Helper.hexToDecimal(hexString)\n"
"          if (decimal == null) scanningError\n"
"          valueInProgress.add(String.fromCodePoint(decimal))\n"
"\n"
"          _cursor = _cursor + charsToPull\n"
"        } else {\n"
"          scanningError\n"
"        }\n"
"\n"
"        isEscaping = false\n"
"      } else if (char == \"\\\\\") {\n"
"        isEscaping = true\n"
"\n"
"      } else {\n"
"        valueInProgress.add(char)\n"
"      }\n"
"    }\n"
"\n"
"    if (isAtEnd()) {\n"
"      // unterminated string\n"
"      scanningError\n"
"      return\n"
"    }\n"
"\n"
"    // consume closing \"\n"
"    advance()\n"
"\n"
"    addToken(Token.String, valueInProgress.join(\"\"))\n"
"  }\n"
"\n"
"  scanNumber () {\n"
"    while (numberChars.contains(peek())) {\n"
"      advance()\n"
"    }\n"
"\n"
"    var number = Num.fromString(Helper.slice(_input, _start, _cursor).join(\"\"))\n"
"\n"
"    if (number == null) {\n"
"      scanningError\n"
"    } else {\n"
"      addToken(Token.Number, number)\n"
"    }\n"
"  }\n"
"\n"
"  scanIdentifier () {\n"
"    while (isAlpha(peek())) {\n"
"      advance()\n"
"    }\n"
"\n"
"    var value = Helper.slice(_input, _start, _cursor).join(\"\")\n"
"    if (value == \"true\") {\n"
"      addToken(Token.Bool, true)\n"
"    } else if (value == \"false\") {\n"
"      addToken(Token.Bool, false)\n"
"    } else if (value == \"null\") {\n"
"      addToken(Token.Null, null)\n"
"    } else {\n"
"      scanningError\n"
"    }\n"
"  }\n"
"\n"
"  advance () {\n"
"    _cursor = _cursor + 1\n"
"    return _input[_cursor - 1]\n"
"  }\n"
"\n"
"  isAlpha (char) {\n"
"    var pt = char.codePoints[0]\n"
"    return (pt >= \"a\".codePoints[0] && pt <= \"z\".codePoints[0]) ||\n"
"           (pt >= \"A\".codePoints[0] && pt <= \"Z\".codePoints[0])\n"
"  }\n"
"\n"
"  isAtEnd () {\n"
"    return _cursor >= _input.count\n"
"  }\n"
"\n"
"  peek () {\n"
"    if (isAtEnd()) return \"\\0\"\n"
"    return _input[_cursor]\n"
"  }\n"
"\n"
"  addToken(type) { addToken(type, null) }\n"
"  addToken(type, value) { _tokens.add(Token.new(type, value, _cursor)) }\n"
"\n"
"  scanningError {\n"
"    var value = Helper.slice(_input, _start, _cursor).join(\"\")\n"
"    var position = Helper.getPositionForIndex(_input, _start)\n"
"    Fiber.abort(\"Invalid JSON: Unexpected \\\"%(value)\\\" at line %(position[\"line\"]), column %(position[\"column\"])\")\n"
"  }\n"
"}\n"
"\n"
"class Token {\n"
"  static LeftBracket { \"LEFT_BRACKET\" }\n"
"  static RightBracket { \"RIGHT_BRACKET\" }\n"
"  static LeftBrace { \"LEFT_BRACE\" }\n"
"  static RightBrace { \"RIGHT_BRACE\" }\n"
"  static Colon { \"COLON\" }\n"
"  static Comma { \"COMMA\" }\n"
"  static String { \"STRING\" }\n"
"  static Number { \"NUMBER\" }\n"
"  static Bool { \"BOOL\" }\n"
"  static Null { \"NULL\"}\n"
"  static End { \"EOF\"}\n"
"\n"
"  construct new(type, value, index) {\n"
"    _type = type\n"
"    _value = value\n"
"    _index = index\n"
"  }\n"
"\n"
"  toString {\n"
"    return (_value != null) ? (_type + \" \" + _value.toString) : _type\n"
"  }\n"
"\n"
"  type { _type }\n"
"  value { _value }\n"
"  index { _index }\n"
"}\n"
"\n"
"// TODO: use Pure when we have a nice module system\n"
"class Helper {\n"
"  static slice(list, start) {\n"
"    return slice(list, start, list.count)\n"
"  }\n"
"  static slice(list, start, end) {\n"
"    var result = []\n"
"    for (index in start...end) {\n"
"      result.add(list[index])\n"
"    }\n"
"    return result\n"
"  }\n"
"  // shout out to http://www.permadi.com/tutorial/numHexToDec/\n"
"  static hexToDecimal (str) {\n"
"    var lastIndex = str.count - 1\n"
"    var power = 0\n"
"    var result = 0\n"
"    for (char in reverse(str)) {\n"
"      var num = Num.fromString(char)\n"
"      if (num == null) return null\n"
"      result = result + (num * exponent(16, power))\n"
"      power = power + 1\n"
"    }\n"
"    return result\n"
"  }\n"
"  static reverse (str) {\n"
"    var result = \"\"\n"
"    for (char in str) {\n"
"      result = char + result\n"
"    }\n"
"    return result\n"
"  }\n"
"  static exponent (value, power) {\n"
"    if (power == 0) return 1\n"
"\n"
"    var result = value\n"
"    for (i in 1...power) {\n"
"      result = result * value\n"
"    }\n"
"    return result\n"
"  }\n"
"  static getPositionForIndex (text, index) {\n"
"    var precedingText = Helper.slice(text, 0, index)\n"
"    var linebreaks = precedingText.where {|char| char == \"\\n\"}\n"
"\n"
"    var reversedPreceding = Helper.reverse(precedingText)\n"
"    var hasSeenLinebreak = false\n"
"    var i = 0\n"
"    while (i < reversedPreceding.count && !hasSeenLinebreak) {\n"
"      if (reversedPreceding[i] == \"\\n\") {\n"
"        hasSeenLinebreak = true\n"
"      }\n"
"      i = i + 1\n"
"    }\n"
"\n"
"    return {\n"
"      \"line\": linebreaks.count,\n"
"      \"column\": i\n"
"    }\n"
"  }\n"
"}";
